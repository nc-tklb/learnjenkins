import dk.netcompany.operations.gradle.plugins.ob.jenkins.PossibleBrokenItemDefinitionException
import dk.netcompany.operations.gradle.plugins.settings.SettingsMap
import dk.netcompany.operations.gradle.plugins.ob.jenkins.RESTJenkinsAPI
import dk.netcompany.operations.gradle.plugins.settings.EncryptionUtils
import dk.netcompany.operations.gradle.plugins.settings.SettingsMap
import dk.netcompany.operations.ob.settings.api.GradleIntegratedSettingsMap
import dk.netcompany.operations.ob.settings.api.OBSettingsEngines
import dk.netcompany.operations.ob.settings.api.SettingsContextMap
import dk.netcompany.operations.ob.settings.api.SettingsEngine


Map readJobConfiguration(String configName = 'default') {
  SettingsMap gs = getGlobalSettings()
  return gs["jenkins-job-configuration-${configName}"] as Map
}

Map readViewConfiguration(String configName = 'default') {
  SettingsMap gs = getGlobalSettings()
  return gs["jenkins-view-configuration-${configName}"] as Map
}

SettingsMap getGlobalSettings() {
  SettingsMap result = null
  forAllSettings("global") { SettingsMap globalSettings ->
    result = globalSettings
  }
  return result
}

/**
 * The closure is used by the generateJenkinsJobs task.
 */
Closure processTemplate = { settings, String templateName, Map<String, ?> data, File outputFile ->
  try {
    settings.processTemplate(
        template: "jenkins/${templateName}",
        extraBindVariables: data,
        output: outputFile,
    )
  } catch (Exception e) {
    String msg = e.getLocalizedMessage()
    if (msg) {
      msg = ": ${msg}"
    } else {
      msg = ''
    }
    throw new RuntimeException("Error processing ${templateName}${msg}", e)
  }
}

task('generateJenkinsJobs', description: 'Generate jenkins jobs from a template') << {
  String configName = parameter("configName")
  Map config
  if (configName != null) {
    config = readJobConfiguration(configName)
  } else {
    config = readJobConfiguration()
  }
  List jobConfig = config.jobs

  // Prepare location where jenkins job files will be written (delete old stuff from directory):
  File outputDir = new File("${project.buildDir}/${config['output-dir']}")
  if (outputDir.exists()) {
    ant.delete(dir: outputDir.absolutePath)
  }
  if (!outputDir.mkdirs()) {
    throw new IllegalStateException("${outputDir} is not a dir or cannot be created!")
  }

  // Read job configuration - it contains information about which jobs to generate:
  SettingsMap settings = getGlobalSettings()
  jobConfig.each { Map<String, ?> jobBundle ->
    Map params = jobBundle['common-template-params'] as Map ?: []
    List jobs = jobBundle['jenkins-jobs'] as List ?: []
    jobs.each { Map<String, ?> job ->
      String name = job['name']
      Map jobParams = job['template-params'] as Map ?: [:]
      // Read job parameters into existing map that already contains the common parameters:
      Map currentParams = [:]
      currentParams << params
      currentParams << jobParams

      //Jobs can be read from 'jobs' directory, or from 'jobs_<configName>' if specified with -PconfigName=
      String configSuffix = configName ? "_" + configName : ""
      String templatesFolder = 'jobs' + configSuffix
      String template = templatesFolder + '/' + job['template']

      // Create separate jobs for each owner - this makes it easier to make the jobs available under the correct tabs/sections in
      // Jenkins - there will be separate tabs/sections for Operations and BY/Unions:
      Map data = [
          jobname    : name,
          description: job['description'],
          params     : currentParams
      ]
      File outputFile = new File(outputDir, "${name}.xml")
      processTemplate(settings, template, data, outputFile)
    }
  }
}

task('createJenkinsViews', description: 'Generate Jenkins xml files with view definitions based on templates.') << {
  boolean skipUpload = parameter("skipUpload") == "true"
  boolean wipeCustomViews = parameter("wipeCustomViews") == "true"
  String configName = parameter("configName")
  Map config
  if (configName != null) {
    config = readViewConfiguration(configName)
  } else {
    config = readViewConfiguration()
  }
  List viewConfig = config.views

  File outputDir = new File("${project.buildDir}/${config['output-dir']}")
  if (outputDir.exists()) {
    ant.delete(dir: outputDir.absolutePath)
  }
  if (!outputDir.mkdirs()) {
    throw new IllegalStateException("${outputDir} is not a dir or cannot be created!")
  }

  // Read view configuration - it contains information about which views to generate:
  SettingsMap globalSettings = getGlobalSettings()
  int counter = 1

  // Generate the XML files containing the view definitions:
  viewConfig.each { view ->
    String template = 'views/' + view['template']
    String name = view['name']
    String description = view['description']
    String viewfile = "${counter++}_view.xml"
    Map params = view['template-params'] as Map
    Map data = [
        name       : name,
        description: description,
        params     : params
    ]
    File outputFile = new File(outputDir, viewfile)
    processTemplate(globalSettings, template, data, outputFile)
    // Add information about the generated view definition to the view configuration (we need it when making the views in Jenkins):
    view['view-definition'] = outputFile.text
    // Correct location if needed - it should not end with a /:
    String location = view['location']
    if (location != null && location.endsWith('/')) {
      view['location'] = location.substring(0, location.length() - 1)
    }
  }

  // XML view files have been generated - create the views:
  if (!skipUpload) {
    String context = requiredParameter("context")
    remoteSessionInContext(context) { SettingsMap settings ->
      int remoteJenkinsPort = settings.jenkinsPort as Integer ?: 443
      tunnel(settings.internalIp, remoteJenkinsPort) { int jenkinsPort ->
        String jenkinsUsername = settings.jenkinsUsername
        String jenkinsPassword = settings.jenkinsPassword
        String jenkinsHost = settings.jenkinsHost ?: settings.internalIp
        String jenkinsProtocol = settings.jenkinsProtocol ?: "https"

        String url = "${jenkinsProtocol}://${jenkinsHost}:${jenkinsPort}"
        RESTJenkinsAPI jApi = new RESTJenkinsAPI(url: url, username: jenkinsUsername, password: jenkinsPassword)

        // Sort viewconfig so views with shortest location comes first in order to build hierarchy root first:
        def rootLocationFirstSorter = { a, b ->
          String aLocation = a['location']
          String bLocation = b['location']
          return aLocation.length().compareTo(bLocation.length())
        }
        viewConfig = viewConfig.sort(rootLocationFirstSorter)

        // First pass through viewconfig is done in order to preserve customly created views. It simply fetches all
        // view-definitions of subviews of one of the views configured in the yml file and adds these views to the viewConfig list:
        if (!wipeCustomViews) { // Preservation of custom views can be skipped using input parameter
          for (int i = 0; i < viewConfig.size(); i++) {
            Map view = viewConfig.get(i) as Map
            String location = view['location']
            String name = view['name']
            String viewPath = "${location}/view/${name}"
            List<String> existingViews
            try {
              existingViews = jApi.getViewNames(viewPath)
            } catch (Throwable ignored) {
              println "Error getting subviews for path ${viewPath} this usually means that there are no subviews."
              existingViews = []
            }
            existingViews.each { existingViewName ->
              boolean isCustomView = !viewConfig.find { it['name'] == existingViewName && it['location'] == viewPath }
              // If the view was added manually we add it the the list of views that should be created, because the view definition is not in the yml file:
              if (isCustomView) {
                String existingViewPath = "${viewPath}/view/${existingViewName}"
                String existingViewDef = jApi.getItemDefinition(existingViewPath)
                // Remove sub-views - Jenkins can't handle them correctly. Child-views will be added using the recursion in this loop:
                int viewsStart = existingViewDef.indexOf("<views>")
                int viewsEnd = existingViewDef.lastIndexOf("</views>")
                if (viewsStart != -1 && viewsEnd != -1) {
                  existingViewDef = existingViewDef.substring(0, viewsStart) + "<views/>" + existingViewDef.substring(viewsEnd + 8)
                }
                Map<String, ?> viewData = [:]
                viewData['view-definition'] = existingViewDef
                viewData['location'] = viewPath
                viewData['name'] = existingViewName
                viewData['server-view'] = true
                // Add custom views to viewConfig list in order to recurse through child-views of custom views:
                viewConfig.add(viewData)
              }
            }
          }
          // Sort viewconfig again so views with shortest location comes first in order to build hierarchy root first:
          viewConfig = viewConfig.sort(rootLocationFirstSorter)
        }

        // Second pass through views creates/updates views:
        viewConfig.each { Map view ->
          String viewDefinition = view['view-definition']
          String location = view['location']
          String name = view['name']
          List<String> existingViews
          existingViews = jApi.getViewNames(location)
          if (existingViews.contains(name)) {
            String existingViewText = view['server-view'] ? " (updating existing serverview)" : ""
            println("View '${name}' already exists. Updating existing view${existingViewText}.")
            jApi.updateItem("${location}view/${name}", viewDefinition)
          } else {
            String existingViewText = view['server-view'] ? " (Re-creating existing serverview)" : ""
            println("View '${name}' does not exist. New view will be created${existingViewText}.")
            jApi.createView(name, viewDefinition, location)
          }
        }
      }

    }
  }
}

/**
 * To use this task, you must have your jenkins credentials stored in settings/<env>/<something>.properties
 *
 * Such a file could look something like:
 *   jenkinsUsername=nth
 *   jenkinsPassword={ENC}...
 *
 * Where the password has been encrypted by (e.g.) the OBEncryptValues task
 */
task('uploadJenkinsJobs', group: 'Netcompany Drift', dependsOn: ['generateJenkinsJobs'],
    description: 'Sync Jenkins jobs to remote server (Requires local-credentials, see task)') << {
  String configName = parameter("configName")
  boolean checkOnlyLocalJobs = Boolean.parseBoolean(parameter("checkOnlyLocalJobs"))
  boolean allowJobDeletion = Boolean.parseBoolean(parameter("allowJobDeletion"))
  String context = requiredParameter("context")
  String matchfilter = parameter("filter") ?: ".*"  // Regex for matching job-names. Use if you only want to update some of the jobs.
  Map config
  if (configName != null) {
    config = readJobConfiguration(configName)
  } else {
    config = readJobConfiguration()
  }
  String outputDir = config['output-dir']
  boolean longWarning = true
  remoteSessionInContext(context) { SettingsMap settings ->
    int remoteJenkinsPort = settings.jenkinsPort as Integer ?: 443
    tunnel(settings.internalIp, remoteJenkinsPort) { int jenkinsPort ->
      String jenkinsUsername = settings.jenkinsUsername
      String jenkinsPassword = settings.jenkinsPassword
      String jenkinsHost = settings.jenkinsHost ?: settings.internalIp
      String jenkinsProtocol = settings.jenkinsProtocol ?: "https"
      String url = "${jenkinsProtocol}://${jenkinsHost}:${jenkinsPort}"
      RESTJenkinsAPI jApi = new RESTJenkinsAPI(url: url, username: jenkinsUsername, password: jenkinsPassword)
      File jenkinsJobDir = new File(project.buildDir, outputDir)
      println "Jobdir: $jenkinsJobDir.absolutePath"
      Set<String> remoteJobs = jApi.getJobNames() as Set<String>
      Set<String> localJobs = [] as Set<String>
      Set<String> allJobs = [] as Set<String>
      for (String baseName : jenkinsJobDir.list()) {
        if (baseName.toLowerCase().endsWith('.xml')) {
          baseName = baseName.substring(0, baseName.length() - 4)
          localJobs.add(baseName)
        }
      }

      allJobs.addAll(remoteJobs)
      allJobs.addAll(localJobs)
      allJobs = allJobs.findAll {it.matches(matchfilter)}
      allJobs.each {println it}
      for (String jobName : allJobs) {
        String action
        String localDef = null
        if (jobName in remoteJobs) {
          String remoteDef = null
          if (jobName in localJobs || !checkOnlyLocalJobs) {
            try {
              remoteDef = jApi.getJobDefinition(jobName)
            } catch (PossibleBrokenItemDefinitionException e) {
              println("WARNING: Cannot fetch the definition of ${jobName} - it is probably broken!  Skipping as it cannot be fixed by remoteAPI calls")
              if (longWarning) {
                longWarning = false
                println("This must be fixed on the remote host manually by fixing \$JENKINS_HOME/jobs/$jobName/config.xml")
                println(" (Usually /var/lib/jenkins/jobs/$jobName/config.xml)")
                println("If the job history is not important, one can solve this by simply deleting \$JENKINS_HOME/jobs/$jobName entirely")
                println("")
                println("AFTER the job have been fixed (or deleted), have jenkins reload its configuration from disk (or restart it)")
              }
            }
          }
          if (jobName in localJobs) {
            localDef = new File(jenkinsJobDir, "${jobName}.xml").text
            action = 'update-project'
            if (!remoteDef) {
              action = 'keep-project'
            } else {
              new File(jenkinsJobDir, "${jobName}.xml-remote").withWriter('UTF-8') { Writer w ->
                w.write(remoteDef)
              }
            }
          } else if (remoteDef != null && (
              remoteDef.contains('This Jenkins item is maintained by env-atpfy OB')
          )) {
            action = 'delete-project'
          } else {
            action = 'keep-project'
          }
        } else {
          action = 'create-project'
        }
        switch (action) {
          case 'create-project':
            if (!localDef) {
              localDef = new File(jenkinsJobDir, "${jobName}.xml").text
            }
            println("Creating ${jobName}.")
            jApi.createJob(jobName, localDef)
            break
          case 'update-project':
            if (!localDef) {
              localDef = new File(jenkinsJobDir, "${jobName}.xml").text
            }

            if (jApi.updateJob(jobName, localDef)) {
              println("Updating ${jobName}.")
            } else {
              println("No changes to ${jobName}")
            }
            break
          case 'delete-project':
            println("Deleting ${jobName}.")
            jApi.deleteJob(jobName)
            break
          case 'keep-project':
            println("Keeping (as-is) ${jobName}  (Not managed by OB).")
            break
          case 'no-change':
            println("No changes required for ${jobName}.")
            break
          default:
            throw new RuntimeException("Unhandled case")
        }
      }
    }
  }
}

tasks.uploadJenkinsJobs.mustRunAfter(tasks.generateJenkinsJobs)


class ValidationUtil {

  public static boolean ensureIsBoolean(String parameter, String value) {
    if (value == 'true' || value == 'false') {
      return Boolean.parseBoolean(parameter)
    }
    throw new IllegalArgumentException("The parameter \"${parameter}\" must be a boolean (and not \"${value}\")")
  }

  public static String ensureIsOneOf(String parameter, String value, String[] permittedValues) {
    return ensureIsOneOf(parameter, value, Arrays.asList(permittedValues))
  }

  public static String ensureIsOneOf(String parameter, String value, Collection<String> permittedValues) {
    if (value in permittedValues) {
      return value
    }
    throw new IllegalArgumentException("The parameter \"${parameter}\" must be one of ${permittedValues} ")
  }

  public
  static List<String> ensureIsOneOrMoreOf(String parameter, String rawValue, Collection<String> permittedValues, String delimiter = ',') {
    List<String> values = rawValue.split(/\Q${delimiter}\E/) as List<String>
    if (values.empty) {
      throw new IllegalArgumentException("The parameter \"${parameter}\" must be one or more of ${permittedValues}")
    }
    if (rawValue.startsWith(delimiter) || rawValue.endsWith(delimiter)) {
      throw new IllegalArgumentException("The parameter \"${parameter}\" starts or ends with an empty element, which is not permitted")
    }
    for (String value : values) {
      if (value in permittedValues) {
        continue
      }
      throw new IllegalArgumentException("The parameter \"${parameter}\" contained \"${value}\", which is *not* one of ${permittedValues}")
    }
    return values
  }
}

task jenkinsValidateParameter << {
  List<String> parameterNames = project.requiredParameter('parameters').split(',')
  for (String parameter : parameterNames) {
    String validateSpecRaw = project.requiredParameter("${parameter}ValidationRule")
    String value = project.requiredParameter(parameter)
    String validateSpec = validateSpecRaw
    String validateSpecArg = ''
    if (validateSpec.contains(':')) {
      String[] parts = validateSpec.split(':', 2)
      validateSpec = parts[0]
      if (parts.length > 1) {
        validateSpecArg = parts[1]
      }
    }

    switch (validateSpec) {
      case 'boolean':
        ValidationUtil.ensureIsBoolean(parameter, value)
        break
      case 'one-of':
        ValidationUtil.ensureIsOneOf(parameter, value, validateSpecArg.split(','))
        break
      case 'one-or-more-of':
        ValidationUtil.ensureIsOneOrMoreOf(parameter, value, validateSpecArg.split(',') as Set<String>)
        break
      case 'validateEncryptedPassword':
        String passwordParameterName = validateSpecArg
        String encryptedValue = project.requiredParameter(passwordParameterName)
        if (EncryptionUtils.isEncrypted(encryptedValue)) {
          EncryptionUtils.decryptValue(encryptedValue,value)
        } else {
          throw new InvalidUserDataException("Please provide an encrypted value")
        }
        break
      case 'passwordParameter':
      case 'masterPasswordType':
      case 'masterPasswordOfContexts':
        String passwordParameterName = validateSpecArg
        if (validateSpec != 'masterPasswordOfContexts' && validateSpecArg == '') {
          throw new InvalidUserDataException("Validation rule \"${validateSpec}\" must have an argument.")
        } else {
          Set<String> mpTypes = [] as TreeSet<String>
          if (validateSpec == 'masterPasswordOfContexts') {
            if (!validateSpec) {
              validateSpecArg = project.requiredParameter('context')
            }
            forAllSettings(validateSpecArg) { Map<String, ?> settings ->
              String mpType = settings['masterPasswordType'] as String
              if (!mpType) {
                throw new InvalidUserDataException("Cannot validate password parameter ${parameter} as context ${settings.getCurrentContext()} has no masterPasswordType property")
              }
              mpTypes.add(mpType)
            }
            if (mpTypes.size() != 1) {
              throw new InvalidUserDataException("Cannot validate password parameter ${parameter} as the contexts ${validateSpecArg} require different passwords: ${mpTypes}")
            } else {
              passwordParameterName = "MASTER_PASSWORD_${mpTypes.first()}"
            }
          } else if (validateSpec == 'masterPasswordType') {
            passwordParameterName = "MASTER_PASSWORD_${validateSpecArg.toUpperCase()}"
          }

          logger.debug("Validating that parameter \"${parameter}\" has the same content as parameter \"${passwordParameterName}\"")
          if (project.requiredParameter(passwordParameterName) != value) {
            throw new InvalidUserDataException("Incorrect password (parameter: ${parameter}).")
          }
        }
        break
      default:
        throw new InvalidUserDataException("Unknown validation rule \"${validateSpec}\" (arg: \"${validateSpecArg}\") for parameter \"${parameter}\"")
    }
  }
}

//TODO: Probably going into OB
class JenkinsHelper {
  /*No need for constructor yet*/

/*Takes a selected applicationstring from Jenkins and an environment variable to determine the context of the servers*/
  protected static List<String> getApplicationContext(Project gProject, String selected, String env, String project) {
    List<String> components = selected.split(",").collect() {it.trim()}.findAll {!it.empty}
    List<String> contexts = new ArrayList<String>()
    SettingsEngine<GradleIntegratedSettingsMap> engine = OBSettingsEngines.newGradleIntegratedSettingsEngine([:], gProject)
    GradleIntegratedSettingsMap globalSettings = engine.getAllSettings(project).first()
    for(String component: components) {
      contexts.add(globalSettings["deploy_context_${env}_${component}"])
    }
    return contexts
  }
}

task("testOB").doLast {
  JenkinsHelper j = new JenkinsHelper()
  forAllSettings{ SettingsMap map ->
    println map.getCurrentContext()
    SettingsContextMap test = map.getSettingsContextMap()
    List<String> properties = ['hostname', 'domainName', 'wl_allow_puppet_domain_config']
    for(SettingsContextMap m: test.getAllSettingsContexts() ) {
      println m.getSourceContext()
      for (String prop : properties) {
        println("${prop}: ${m.getPropertySources(prop)}")
      }
//      println m.get("wl_allow_puppet_domain_config",null)
    }
  }
}
